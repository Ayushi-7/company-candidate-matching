// type Offer = { from: number, to: number, fromCo: boolean }
// type Run = { trace: Offer[], out: Hire[] }

// Returns a random int i where min <= i < max
function randomInt(min, max) {
return Math.floor(Math.random() * (max - min)) + min;
}

// helper function to make an array of non-repeated numbers
// generatePref(n: number): number[]
function generatePref(n){
  let preference = Array.create(n, -1);
  for(let j = 0; j < n; ++j){
    preference[j] = validInp(n, preference);
  }
  return preference;
}

//helper function to decide whether the number generated has already been used
function validInp(num, arr){
  let val = randomInt(0, num);
    if(arr.includes(val)){
      return validInp(num, arr);
    }
  return val;
}

// generateInput(n: number): number[][]
function generateInput(n){
  let output = Array.create(n, 0);
  for(let i = 0; i < n; ++i){
    output[i] = generatePref(n);
  }
  return output;
}

// runOracle(f: (companies: number[][], candidates: number[][]) => Run): void
function runOracle(f) {
let numTests = 20; // Change this to some reasonably large value
for (let i = 0; i < numTests; ++i) {
  let n = 5; // Change this to some reasonable size
  let companies = generateInput(n);
  let candidates = generateInput(n);
  let aRun = f(companies, candidates);
  let arrOffers = aRun.trace;
  let finalHire = aRun.out;

  test('proposals are not repeated', function(){
    //checks if every offer is made only once
    function same(from, to, fromCo){
      let count = 0;
      for(let i = 0; i < arrOffers.length; ++i){
        if(from === arrOffers[i].from && to === arrOffers[i].to && fromCo === arrOffers[i].fromCo){
          count = count + 1;//if the offer appears more than once, the count becomes more than one
        }
      }
      return count;
    }
    assert(arrOffers.every(offer => same(offer.from, offer.to, offer.fromCo) === 1));
  });


let hires = [];//creating a new array in which we store the matched pairs generated by our algorithm traversing through all the offers
function isItMatched(arr, toBeChecked, isComp){//checks whether the given candidate or company is already matched to something else
  if(isComp){
    return hires.some(h => h.company === toBeChecked);
  }
  else{
    return hires.some(h => h.candidate === toBeChecked);
  }
  //returns true if it is matched
}

function getPref(offer){//if the company offers, this returns the company's preference array and same for candidate
  if(offer.fromCo){
    return companies;
  }
  else{
    return candidates;
  }
}

let x = arrOffers.length;
let countCand = Array.create(x, 0);//creating a counter that keeps track of the number of offers that a candidate has made
let countComp = Array.create(x, 0);

function traverse(index){//if the offer is from a company then it's counter is incremented in the countComp[]
  let offer = arrOffers[index];
  if(offer.fromCo){
    countComp[offer.from] = countComp[offer.from] + 1;
  }
  else{
    countCand[offer.from] = countCand[offer.from] + 1;
  }
}

function proposalIsInOrder(arrOffers){
  let bool = false;
  for(let i = 0; i < arrOffers.length; ++i){
    bool = false;
    let offer = arrOffers[i];
    if(!isItMatched(hires, offer.from, offer.fromCo)){//if the offering company/candidate isn't already matched
      let offersMade = offer.fromCo ? countComp[offer.from] : countCand[offer.from];//finds the number of offers comp/cand has made till now
      //gets the next cand/comp from it's preference array and checks if it's the same as the one that it's offering to now
      //to ensure that all the previous comp/cand in it's preference list have been given offers
      bool = (getPref(offer)[offer.from][offersMade] === offer.to);
      if(bool){
        traverse(i);//if that's true then we need to increment the number of offers made
        match(offer);//calls match which matches the candidate and company based on some criterias
      }
    }
    assert(bool);
  }
}

test('proposals are in order', function(){
  proposalIsInOrder(arrOffers);
});


function match(offer){
  if(offer.fromCo && !isItMatched(hires, offer.to, !offer.fromCo)){//if the candidate isn't matched to someone else, it immediately accepts
     ////isItMatched(arr, toBeChecked, isComp)
    hires.push({company: offer.from, candidate: offer.to});
  }
  if(!offer.fromCo && !isItMatched(hires, offer.to, !offer.fromCo)){
     ////isItMatched(arr, toBeChecked, isComp)

    hires.push({company: offer.to, candidate: offer.from});
  }
  else if(offer.fromCo && isItMatched(hires, offer.to, !offer.fromCo)){
    let j = findIndexInHires(hires, offer.to, offer.fromCo);//find the old match index in hires using helper method
    let comp1 = hires[j].company;//old company
    let comp2 = offer.from;//new offer
    let candPref = candidates[offer.to];
    if(candPref.indexOf(comp1) > candPref.indexOf(comp2)){//if new offer has greater preference
      hires[j] = {company : comp2, candidate: offer.to};//old match is removed and new match is added
    }
  }
  else if(!offer.fromCo && isItMatched(hires, offer.to, !offer.fromCo)){
    let j = findIndexInHires(hires, offer.to, offer.fromCo);
    let cand1 = hires[j].candidate;
    let cand2 = offer.from;
    let compPref = companies[offer.to];
    if(compPref.indexOf(cand1) > compPref.indexOf(cand2)){
      hires[j] = {company : offer.to, candidate: cand2};
    }
  }
}

  function findIndexInHires(arr, value, fromCo){//finds the index in hires[] 
  let index = (fromCo ? arr.findIndex(i => i.candidate === value) : arr.findIndex(i => i.company === value));
  return index;
  }

test('output is correct', function(){
  assert(finalHire.every(i => hires.some(pair => pair.company === i.company && pair.candidate === i.candidate)));
});

test('length is correct', function(){
  assert(finalHire.length === hires.length);
});


  }
}

const oracleLib = require('oracle');
runOracle(oracleLib.traceWheat1);
// runOracle(oracleLib.traceChaff1);
